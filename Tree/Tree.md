# 数据结构树

## 什么是树，为什么会出现树

>对与大量数据的输入，线性表的访问时间太慢，不适合使用，于是乎大佬们搞出了树。树模拟了具有树状结构的数据集合

>对于树的定义:
    >树可以用集中方法定义，定义树的一种自然方法是递归的方法。一棵树是一些节点的集合。这个集合可以是空集；若非空，则一棵树由称作根(root)的节点r以及0个或多个非空的子树组成，这些子树中每一棵的根都被来自根r的一条有方向的边连接。每一颗子树叫做根的儿子，而r是每一棵子树的根的父亲。
----
>树的一些术语:
    >节点的度：节点的子节点个数
    >树的度:一棵树中，最大的节点的度称为树的度
    >节点的层次:
    >树的高度:最大层次数

## 树的实现

>实现树的一种方法是可以实在每一个节点除数据外还有一些指针，使得该节点的每一个节点都有一个指针指向它的字节点,所以呢我们可以像下面这样来定义树的节 点

```C
typedef struct Node{
    int data;
    TreeNode FirstChild;
    TreeNode NextChild;
} *TreeNode;
 ```

>这个做法呢是把每个子节点都放在树节点的链表中，细心点会发现这个和双链表有点像，其实呢树也是在表的基础上的来的，所以把表学好是很重要的。

## 树的应用及遍历

>树的应用由很多种，其中最常见的是很多Unix like 操作系统的目录结构，现在假设有一个目录"/usr"我们要遍历它的子目录以及其中的文件,并且规定，文件的深度每上升1，我们就在输出时在其前面多输出一个制表符

```C
void ListDir(Directory D,int Depth){
    if(D is a legitimate entry){
        PrintName(D,Depth);
        if(D is a directory)
            for each child,C of D
                ListDir(C;Depth+1)
    }
}
void ListDirectory(Directory D){
    ListDir(D,0);
}
```

>可以看到，上述代码的核心是不断的递归调用ListDir()函函数，如果是一个目录，我们先输出它，再递归地一个一个地处理它所有的儿子。直到遍历完全为止，这种遍历叫做先序遍历。即:对节点的处理工作是在它子节点前进行的。

>树的后序遍历：
    >在后续遍历中，每个子节点的处理是在其子节点之后处理的

## 二叉树

    二叉树是一棵树，其中每个节点都不能有多于两个的子节点,二叉树的一个性质是平均二叉树的深度要比